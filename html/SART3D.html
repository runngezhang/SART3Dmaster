
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>SART3D - 3D Spatial Audio Rendering Toolbox</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-09-18"><meta name="DC.source" content="SART3D.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>SART3D - 3D Spatial Audio Rendering Toolbox</h1><!--introduction--><p>This is the main function of the toolbox. It generates the GUI from the initial configuration structure obtained by <b>gConfig</b> and <b>gCheckConfig</b>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Initialization</a></li><li><a href="#8">Programmatic GUI construction</a></li><li><a href="#10">=== Component Placement ============================================</a></li><li><a href="#11">== Calculate initial rendering coefficients and filter objects =====</a></li><li><a href="#12">=== Initialize Drag &amp; Drop== =======================================</a></li><li><a href="#13">=== Audio Objects ===================================================</a></li><li><a href="#16">=== Initialize Repproduction =======================================</a></li><li><a href="#17">=== While play button is on ====================================</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [] = SART3D()
</pre><h2>Initialization<a name="3"></a></h2><p>Toolbox initialization.</p><p>Clear workspace and clean screen:</p><pre class="codeinput">clear <span class="string">all</span>;
close <span class="string">all</span>;
clearvars <span class="string">-global</span>;
clc;
</pre><p>Add folders to path:</p><pre class="codeinput">addpath(<span class="string">'images'</span>, genpath(<span class="string">'audioscenes'</span>), <span class="string">'objects'</span>, <span class="string">'setups'</span>,<span class="keyword">...</span>
    <span class="string">'gui_elements'</span>, <span class="string">'configurations'</span>, genpath(<span class="string">'functions'</span>));
</pre><p>Load configuration structure obtained by <b>gConfig.m</b>. You can select your own MAT file containing the intended configuration structure.</p><pre class="codeinput"><span class="keyword">global</span> conf;
load(<span class="string">'conf.mat'</span>,<span class="string">'conf'</span>);
</pre><p>Initialize the data structure used by the GUI in guidata. Contains:</p><div><ul><li>Data matrix with rendering filters (or coefficients) (1)</li><li>Logical matrix indicating loudspeakers contributing to synthesis (2)</li><li>Filtering objects (3)</li><li>Indices of changing loudspeaker for each source (4)</li><li>Inactive loudspeakers for each source (5)</li><li>Virtual source coordinates managed by the GUI (6)</li></ul></div><pre class="codeinput">data.H = zeros(conf.nVS, conf.nLS, conf.nCoeffs); <span class="comment">% (1)</span>
data.I = zeros(conf.nVS, conf.nLS); <span class="comment">% (2)</span>
data.Ho = cell(conf.nVS, conf.nLS); <span class="comment">% (3)</span>
data.Ichange = cell(conf.nVS); <span class="comment">% (4)</span>
data.Izeros = cell(conf.nVS); <span class="comment">% (5)</span>
data.vSSph = reshape(cell2mat(conf.VS.coord),3,[]); <span class="comment">% (6)</span>
</pre><h2>Programmatic GUI construction<a name="8"></a></h2><p>This section starts the code to build the GUI according to the configuration structure.</p><p>Global variables needed to speed up processing.</p><pre class="codeinput"><span class="keyword">global</span> handles v;

<span class="comment">%--- Get dimensions of components in GUI ---------------------------</span>
v = gSizes;

<span class="comment">%--- Create figure (not shown until all elements are load) ---------</span>
f = figure(<span class="string">'Visible'</span>, <span class="string">'on'</span>, <span class="string">'Position'</span>, v.bounds,<span class="keyword">...</span>
    <span class="string">'Color'</span>, v.bgColor);

<span class="comment">%-- Window Title ---------------------------------------------------</span>
set(f, <span class="string">'Name'</span>, <span class="string">'SART-3D (3D Spatial Audio Rendering Toolbox)'</span>,<span class="keyword">...</span>
    <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>, <span class="string">'MenuBar'</span>, <span class="string">'none'</span>);

set(f,<span class="string">'Renderer'</span>,<span class="string">'painters'</span>);

<span class="comment">%-- Create Axes ----------------------------------------------------</span>
gDrawScene(v.bounds_axes_plan, <span class="string">'plan'</span>);
hold <span class="string">on</span>;
gDrawScene(v.bounds_axes_profile, <span class="string">'profile'</span>);
hold <span class="string">on</span>;

<span class="comment">% We declare graphical data from GUI to start loading components</span>
handles = guihandles(f);
</pre><img vspace="5" hspace="5" src="SART3D_01.png" alt=""> <h2>=== Component Placement ============================================<a name="10"></a></h2><pre class="codeinput"><span class="comment">% *********************************************************************</span>
<span class="comment">% Script that places components in the GUI</span>
<span class="comment">%run('mPlaceComp.m');</span>
mPlaceComp;
<span class="comment">% *********************************************************************</span>

<span class="comment">% -- Logo -----------</span>
GImage(gcf, <span class="string">''</span>, v.bounds_logo, <span class="string">'logo_spat.png'</span>);

<span class="comment">% Move GUI to top-right corner:</span>
movegui(f, <span class="string">'northwest'</span>);

<span class="comment">% Make the GUI visible:</span>
set(f, <span class="string">'Visible'</span>, <span class="string">'on'</span>);

<span class="comment">% We load globally all the graphical objects that will be modified</span>
<span class="comment">% through execution so that other functions do not need to load them.</span>
<span class="comment">% This makes the program faster.</span>

handles = guihandles(f);
</pre><img vspace="5" hspace="5" src="SART3D_02.png" alt=""> <h2>== Calculate initial rendering coefficients and filter objects =====<a name="11"></a></h2><pre class="codeinput"><span class="keyword">for</span> ii = 1:conf.nVS
    <span class="keyword">for</span> jj = 1:conf.nLS
        data.Ho{ii,jj} = GfftFIRm(conf.SamplesPerFrame,zeros(conf.nCoeffs,1));
    <span class="keyword">end</span>
<span class="keyword">end</span>

guidata(f,data);

<span class="keyword">for</span> ii = 1:conf.nVS
    gRefreshH(f, ii);
<span class="keyword">end</span>
data = guidata(f);
</pre><h2>=== Initialize Drag &amp; Drop== =======================================<a name="12"></a></h2><pre class="codeinput"><span class="comment">% Store virtual source (objects) positions in plan and profile view</span>
data.VSxy = zeros(2, conf.nVS);
data.VSyz = zeros(2, conf.nVS);
<span class="keyword">for</span> ii = 1:conf.nVS
     VSaux = get(handles.textsVS(ii), <span class="string">'Position'</span>).'; <span class="comment">% Plan x-y</span>
     data.VSxy(1,ii) = VSaux(1) + VSaux(3)/2;
     data.VSxy(2,ii) = VSaux(2) + VSaux(4)/2;
     VSaux = get(handles.textsVSProfile(ii), <span class="string">'Position'</span>).'; <span class="comment">% Profile y-z</span>
     data.VSyz(1,ii) = VSaux(1) + VSaux(3)/2;
     data.VSyz(2,ii) = VSaux(2) + VSaux(4)/2;
<span class="keyword">end</span>

<span class="comment">% Used for positioning when using spatial resolution</span>
<span class="keyword">global</span> lastp
lastp = [0;0;0];

<span class="comment">% Save changes in guidata:</span>
guidata(f, data);

<span class="comment">% Relate mouse motion to Drag And Drop custom function:</span>
set(f, <span class="string">'WindowButtonMotionFcn'</span>, @gDnD);
</pre><h2>=== Audio Objects ===================================================<a name="13"></a></h2><p>Initialize DSP System Input Audio Objects</p><pre class="codeinput">data.in = {conf.nVS};
<span class="keyword">for</span> ii = 1:conf.nVS
    data.in{ii} = dsp.AudioFileReader;
    data.in{ii}.Filename = conf.VS.fileNames{ii};
    data.in{ii}.SamplesPerFrame = conf.SamplesPerFrame;
    data.in{ii}.PlayCount = inf;
<span class="keyword">end</span>
guidata(f, data);
</pre><pre class="codeinput"><span class="keyword">end</span>


<span class="comment">% ============= MAIN PLAYBACK FUNCTION ================================</span>
<span class="keyword">function</span> tbPlayOnCallback(hObject, ~)
</pre><pre class="codeinput">    <span class="keyword">global</span> handles conf
</pre><h2>=== Initialize Repproduction =======================================<a name="16"></a></h2><p>Load GUI data</p><pre class="codeinput">    data = guidata(hObject);

    <span class="comment">% Initialize output object</span>
    out = dsp.AudioPlayer;

    <span class="comment">% Selected reproduction device from popupMenu:</span>
    deviceNames = get(handles.pmDevice, <span class="string">'String'</span>);
    deviceNameSelected = deviceNames(get(handles.pmDevice, <span class="string">'Value'</span>));
    auxchar = char(deviceNameSelected);
    out.DeviceName = auxchar;

    <span class="comment">% Set reproduction parameters:</span>
    <span class="comment">%out.SampleRate = data.in{1}.SampleRate;</span>
    out.SampleRate = conf.fs;
    out.BufferSizeSource = <span class="string">'Property'</span>;

    bufferSize = get(handles.pmBufferSize, <span class="string">'String'</span>);
    bufferSizeSelected = bufferSize(get(handles.pmBufferSize, <span class="string">'Value'</span>));
    out.BufferSize = str2double(bufferSizeSelected);

    out.ChannelMappingSource = <span class="string">'Property'</span>;
    out.ChannelMapping = conf.driver.ChannelMapping;
    out.QueueDuration = conf.QueueDuration;

    <span class="comment">% Initialize output data:</span>
    voidChannels = zeros(conf.SamplesPerFrame, conf.nLS);

    <span class="comment">% Initialize required output data for smoothing:</span>
    y  = voidChannels;
    y1 = voidChannels;
    y2 = voidChannels;

    <span class="comment">% Initialize input data:</span>
    x = zeros(conf.SamplesPerFrame,conf.nVS);

    <span class="comment">% Total audio out (will accumulate signals from different sources)</span>
    audio_out = voidChannels;

    <span class="comment">% Auxiliar vector storing last-frame contributing loudspeakers</span>
    Ilast = cell(conf.nVS);

    <span class="comment">% linear fade-in/out</span>
    <span class="comment">%fadeOutMono = linspace(1, 0, conf.SamplesPerFrame).'; % [SamplesPerFrame]</span>
    <span class="comment">%fadeInMono  = linspace(0, 1, conf.SamplesPerFrame).';</span>

    <span class="comment">% hanning fade-in/out</span>
    auxhann = hann(2*conf.SamplesPerFrame,<span class="string">'periodic'</span>);
    fadeInMono = auxhann(1:conf.SamplesPerFrame);
    fadeOutMono = auxhann(conf.SamplesPerFrame+1:end);

    fadeOut = repmat(fadeOutMono, 1, conf.nLS); <span class="comment">% [SamplesPerFrame x nLS]</span>
    fadeIn = repmat(fadeInMono, 1, conf.nLS);
</pre><h2>=== While play button is on ====================================<a name="17"></a></h2><pre class="codeinput">    <span class="keyword">while</span> get(hObject, <span class="string">'State'</span>) <span class="comment">% 'On' by default</span>
        <span class="comment">% Load data from GUI (needed to get updated filters)</span>
        data = guidata(hObject);

        <span class="comment">% If play button is pressed again, break</span>
        <span class="keyword">if</span> strcmp(get(hObject, <span class="string">'State'</span>), <span class="string">'off'</span>)
            <span class="keyword">break</span>;
        <span class="keyword">end</span>

        <span class="keyword">for</span> ii = 1:conf.nVS
            <span class="comment">% Read audio files:</span>
            x(:,ii) = step(data.in{ii});

            y1 = voidChannels;
            y2 = voidChannels;

            <span class="comment">% Play audio from sources with active checkbox. If not, mute by</span>
            <span class="comment">% adding zeros. This is necessary for having synchronized</span>
            <span class="comment">% sources</span>
            <span class="keyword">if</span> get(handles.checkboxesVS(ii), <span class="string">'Value'</span>)

                <span class="comment">% Cross-fading</span>
                <span class="keyword">if</span> strcmp(conf.fadeBuffers, <span class="string">'on'</span>)

                    <span class="comment">% Get each loudspeaker signal:</span>
                    <span class="comment">% This works ok, but is computationally more expensive</span>
                    <span class="comment">% for jj = 1:conf.nLS</span>
                    <span class="comment">%    y1(:, jj) = steplast(data.Ho{ii,jj},x(:,ii));</span>
                    <span class="comment">%    y2(:, jj) = step(data.Ho{ii,jj},x(:,ii));</span>
                    <span class="comment">% end</span>

                    y1 = voidChannels;
                    y2 = voidChannels;
                    Ip = find(data.I(ii,:)~=0);
                    I = unique([Ip,Ilast{ii}]);
                    <span class="keyword">for</span> jj = 1:length(I)
                        y1(:, I(jj)) = steplast(data.Ho{ii,I(jj)},x(:,ii));
                        y2(:, I(jj)) = step(data.Ho{ii,I(jj)},x(:,ii));
                    <span class="keyword">end</span>
                    Ilast{ii} = Ip;

                    <span class="comment">% Apply cross-fading:</span>
                    y = y1.*fadeOut+y2.*fadeIn; <span class="comment">% Mix fade-in and fade-out signal</span>

                <span class="keyword">else</span> <span class="comment">% No frame smoothing</span>
                    y = voidChannels;
                    Ip = find(data.I(ii,:)~=0);
                    <span class="keyword">for</span> jj = 1:length(Ip)
                       y(:, Ip(jj)) = step(data.Ho{ii,Ip(jj)},x(:,ii));
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                guidata(gcf,data);
            <span class="keyword">else</span>
                y = voidChannels; <span class="comment">% Mute</span>
            <span class="keyword">end</span>
            <span class="comment">% Accumulate audio from different sources</span>
            audio_out = audio_out + y;

         <span class="keyword">end</span>

         step(out, audio_out); <span class="comment">% Reproduce audio stream</span>

         <span class="comment">% Reset audio stream for next callback.</span>
         audio_out = voidChannels;
         drawnow;
    <span class="keyword">end</span>

<span class="comment">%     % Release resources:</span>
<span class="comment">%     for ii = 1:conf.nVS</span>
<span class="comment">%         release(data.in{ii});</span>
<span class="comment">%     end</span>
<span class="comment">%     release(out);</span>
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> tbPlayOffCallback(hObject, ~)
    <span class="comment">% Exit from tbPlayOffCallback()'s "while"</span>
    set(hObject, <span class="string">'State'</span>, <span class="string">'off'</span>);
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% SART3D - 3D Spatial Audio Rendering Toolbox
% This is the main function of the toolbox. It generates the GUI from the
% initial configuration structure obtained by *gConfig* and *gCheckConfig*.

%%
function [] = SART3D()

%% Initialization
% Toolbox initialization.

%%
% Clear workspace and clean screen:
clear all;
close all;
clearvars -global;
clc;

%%
% Add folders to path:
addpath('images', genpath('audioscenes'), 'objects', 'setups',...
    'gui_elements', 'configurations', genpath('functions'));

%%
% Load configuration structure obtained by *gConfig.m*. You can select your
% own MAT file containing the intended configuration structure.
global conf;
load('conf.mat','conf');

%%
% Initialize the data structure used by the GUI in guidata. Contains:
%
% * Data matrix with rendering filters (or coefficients) (1)
% * Logical matrix indicating loudspeakers contributing to synthesis (2)
% * Filtering objects (3)
% * Indices of changing loudspeaker for each source (4)
% * Inactive loudspeakers for each source (5)
% * Virtual source coordinates managed by the GUI (6)

data.H = zeros(conf.nVS, conf.nLS, conf.nCoeffs); % (1)
data.I = zeros(conf.nVS, conf.nLS); % (2)
data.Ho = cell(conf.nVS, conf.nLS); % (3)  
data.Ichange = cell(conf.nVS); % (4)
data.Izeros = cell(conf.nVS); % (5)
data.vSSph = reshape(cell2mat(conf.VS.coord),3,[]); % (6)

%% Programmatic GUI construction
% This section starts the code to build the GUI according to the
% configuration structure.

%%
% Global variables needed to speed up processing.
global handles v;

%REPLACE_WITH_DASH_DASH- Get dimensions of components in GUI REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
v = gSizes;

%REPLACE_WITH_DASH_DASH- Create figure (not shown until all elements are load) REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
f = figure('Visible', 'on', 'Position', v.bounds,...
    'Color', v.bgColor);

%REPLACE_WITH_DASH_DASH Window Title REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
set(f, 'Name', 'SART-3D (3D Spatial Audio Rendering Toolbox)',...
    'NumberTitle', 'off', 'MenuBar', 'none');

set(f,'Renderer','painters');

%REPLACE_WITH_DASH_DASH Create Axes REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
gDrawScene(v.bounds_axes_plan, 'plan');
hold on;
gDrawScene(v.bounds_axes_profile, 'profile');
hold on;

% We declare graphical data from GUI to start loading components
handles = guihandles(f);

%% === Component Placement ============================================

% *********************************************************************
% Script that places components in the GUI
%run('mPlaceComp.m');
mPlaceComp;
% *********************************************************************

% REPLACE_WITH_DASH_DASH Logo REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
GImage(gcf, '', v.bounds_logo, 'logo_spat.png');

% Move GUI to top-right corner:
movegui(f, 'northwest'); 

% Make the GUI visible:
set(f, 'Visible', 'on');

% We load globally all the graphical objects that will be modified
% through execution so that other functions do not need to load them.
% This makes the program faster.

handles = guihandles(f);

%% == Calculate initial rendering coefficients and filter objects =====

for ii = 1:conf.nVS
    for jj = 1:conf.nLS
        data.Ho{ii,jj} = GfftFIRm(conf.SamplesPerFrame,zeros(conf.nCoeffs,1));
    end
end

guidata(f,data);

for ii = 1:conf.nVS
    gRefreshH(f, ii);
end
data = guidata(f);

%% === Initialize Drag & Drop== =======================================

% Store virtual source (objects) positions in plan and profile view
data.VSxy = zeros(2, conf.nVS);
data.VSyz = zeros(2, conf.nVS);
for ii = 1:conf.nVS
     VSaux = get(handles.textsVS(ii), 'Position').'; % Plan x-y
     data.VSxy(1,ii) = VSaux(1) + VSaux(3)/2;
     data.VSxy(2,ii) = VSaux(2) + VSaux(4)/2;
     VSaux = get(handles.textsVSProfile(ii), 'Position').'; % Profile y-z
     data.VSyz(1,ii) = VSaux(1) + VSaux(3)/2;
     data.VSyz(2,ii) = VSaux(2) + VSaux(4)/2;
end

% Used for positioning when using spatial resolution
global lastp
lastp = [0;0;0];

% Save changes in guidata:
guidata(f, data);

% Relate mouse motion to Drag And Drop custom function:
set(f, 'WindowButtonMotionFcn', @gDnD);


%% === Audio Objects ===================================================
% Initialize DSP System Input Audio Objects
data.in = {conf.nVS};
for ii = 1:conf.nVS
    data.in{ii} = dsp.AudioFileReader;
    data.in{ii}.Filename = conf.VS.fileNames{ii};
    data.in{ii}.SamplesPerFrame = conf.SamplesPerFrame;
    data.in{ii}.PlayCount = inf;
end
guidata(f, data);


end


% ============= MAIN PLAYBACK FUNCTION ================================
function tbPlayOnCallback(hObject, ~)
    global handles conf

%% === Initialize Repproduction =======================================
    % Load GUI data
    data = guidata(hObject);
    
    % Initialize output object
    out = dsp.AudioPlayer;
    
    % Selected reproduction device from popupMenu:
    deviceNames = get(handles.pmDevice, 'String');
    deviceNameSelected = deviceNames(get(handles.pmDevice, 'Value'));
    auxchar = char(deviceNameSelected);
    out.DeviceName = auxchar;    
    
    % Set reproduction parameters:
    %out.SampleRate = data.in{1}.SampleRate;
    out.SampleRate = conf.fs;
    out.BufferSizeSource = 'Property';
    
    bufferSize = get(handles.pmBufferSize, 'String');
    bufferSizeSelected = bufferSize(get(handles.pmBufferSize, 'Value'));   
    out.BufferSize = str2double(bufferSizeSelected);
    
    out.ChannelMappingSource = 'Property';
    out.ChannelMapping = conf.driver.ChannelMapping;
    out.QueueDuration = conf.QueueDuration;
    
    % Initialize output data:
    voidChannels = zeros(conf.SamplesPerFrame, conf.nLS);
    
    % Initialize required output data for smoothing:
    y  = voidChannels;
    y1 = voidChannels;
    y2 = voidChannels;
    
    % Initialize input data:
    x = zeros(conf.SamplesPerFrame,conf.nVS);
    
    % Total audio out (will accumulate signals from different sources)   
    audio_out = voidChannels;
    
    % Auxiliar vector storing last-frame contributing loudspeakers
    Ilast = cell(conf.nVS);
    
    % linear fade-in/out
    %fadeOutMono = linspace(1, 0, conf.SamplesPerFrame).'; % [SamplesPerFrame]
    %fadeInMono  = linspace(0, 1, conf.SamplesPerFrame).';
    
    % hanning fade-in/out
    auxhann = hann(2*conf.SamplesPerFrame,'periodic');
    fadeInMono = auxhann(1:conf.SamplesPerFrame);
    fadeOutMono = auxhann(conf.SamplesPerFrame+1:end);
    
    fadeOut = repmat(fadeOutMono, 1, conf.nLS); % [SamplesPerFrame x nLS]
    fadeIn = repmat(fadeInMono, 1, conf.nLS);
    
    %% === While play button is on ====================================
    
    while get(hObject, 'State') % 'On' by default
        % Load data from GUI (needed to get updated filters)       
        data = guidata(hObject);

        % If play button is pressed again, break
        if strcmp(get(hObject, 'State'), 'off')
            break;
        end
                
        for ii = 1:conf.nVS
            % Read audio files:
            x(:,ii) = step(data.in{ii});
            
            y1 = voidChannels;
            y2 = voidChannels;
            
            % Play audio from sources with active checkbox. If not, mute by
            % adding zeros. This is necessary for having synchronized
            % sources
            if get(handles.checkboxesVS(ii), 'Value')
                
                % Cross-fading
                if strcmp(conf.fadeBuffers, 'on')
                    
                    % Get each loudspeaker signal:   
                    % This works ok, but is computationally more expensive
                    % for jj = 1:conf.nLS
                    %    y1(:, jj) = steplast(data.Ho{ii,jj},x(:,ii));
                    %    y2(:, jj) = step(data.Ho{ii,jj},x(:,ii));
                    % end
                
                    y1 = voidChannels;
                    y2 = voidChannels;
                    Ip = find(data.I(ii,:)~=0);
                    I = unique([Ip,Ilast{ii}]);
                    for jj = 1:length(I)
                        y1(:, I(jj)) = steplast(data.Ho{ii,I(jj)},x(:,ii));
                        y2(:, I(jj)) = step(data.Ho{ii,I(jj)},x(:,ii));
                    end
                    Ilast{ii} = Ip;
                    
                    % Apply cross-fading:
                    y = y1.*fadeOut+y2.*fadeIn; % Mix fade-in and fade-out signal
                    
                else % No frame smoothing
                    y = voidChannels;
                    Ip = find(data.I(ii,:)~=0);
                    for jj = 1:length(Ip)
                       y(:, Ip(jj)) = step(data.Ho{ii,Ip(jj)},x(:,ii));
                    end
                end 
                
                guidata(gcf,data);
            else
                y = voidChannels; % Mute
            end
            % Accumulate audio from different sources
            audio_out = audio_out + y;                       
           
         end

         step(out, audio_out); % Reproduce audio stream
         
         % Reset audio stream for next callback.
         audio_out = voidChannels;        
         drawnow;
    end
    
%     % Release resources:
%     for ii = 1:conf.nVS
%         release(data.in{ii});
%     end
%     release(out);
    
end

function tbPlayOffCallback(hObject, ~)
    % Exit from tbPlayOffCallback()'s "while"
    set(hObject, 'State', 'off');
end


##### SOURCE END #####
--></body></html>